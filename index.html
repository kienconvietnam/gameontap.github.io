<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ma S√≥i AI Ngo·∫°i Tuy·∫øn</title>
    <!-- T·∫£i Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- T·∫£i Icon Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        /* Giao di·ªán ƒê√™m Huy·ªÅn B√≠ - C·∫£i ti·∫øn */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #18191a; /* N·ªÅn t·ªëi d·ªãu h∆°n */
            color: #E4E6EB; /* M√†u ch·ªØ s√°ng */
        }
        
        header h1 {
            color: #FFD700; /* M√†u v√†ng ƒë·ªìng */
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .game-card-container {
            background-color: #242526; /* Th·∫ª t·ªëi ·∫•m h∆°n */
            border: 1px solid #3A3B3C;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); 
            transition: box-shadow 0.3s ease;
        }

        .game-card-container:hover {
             box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }

        #chat-messages {
            height: 400px;
            overflow-y: auto;
        }
        
        #chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        #chat-messages::-webkit-scrollbar-thumb {
            background-color: #50BFE6; 
            border-radius: 4px;
        }
        #chat-messages::-webkit-scrollbar-track {
            background-color: #1f2937; 
        }
        
        .lucide {
            width: 20px;
            height: 20px;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 1rem;
            text-align: center;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold">MA S√ìI AI NGO·∫†I TUY·∫æN</h1>
        <p class="text-gray-400 mt-2" id="user-info">Ch·∫ø ƒë·ªô offline: Game s·∫Ω nhanh h∆°n!</p>
    </header>

    <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">
        
        <!-- C·ªôt 1: Th√¥ng tin ng∆∞·ªùi ch∆°i v√† tr·∫°ng th√°i -->
        <div class="lg:col-span-1 space-y-6">
            
            <!-- Tr·∫°ng th√°i Game -->
            <div id="game-status-container" class="game-card-container p-6 relative">
                <div id="loading-overlay" class="loading-overlay hidden">
                    <p class="text-white text-xl font-bold p-4 bg-gray-900/80 rounded-lg">AI ƒêang X·ª≠ L√Ω...</p>
                </div>
                
                <div id="game-status" class="text-center">
                    <p class="text-gray-300">Nh·∫•n B·∫ÆT ƒê·∫¶U V√ÅN M·ªöI ƒë·ªÉ ch∆°i.</p>
                </div>
                <div class="mt-4 text-center">
                    <button id="start-btn" onclick="startGameOffline()" class="px-6 py-3 bg-red-700 text-white font-black uppercase tracking-wider rounded-xl shadow-xl hover:bg-red-800 transition-colors transform hover:scale-[1.02]">
                        B·∫ÆT ƒê·∫¶U V√ÅN M·ªöI
                    </button>
                </div>
            </div>

            <!-- Vai tr√≤ c·ªßa B·∫°n -->
            <div class="game-card-container p-6">
                <h2 class="text-xl font-bold text-amber-400 mb-4 flex items-center">
                    <i data-lucide="shield" class="lucide mr-2 text-amber-400"></i>
                    Vai Tr√≤ C·ªßa B·∫°n
                </h2>
                <div id="role-card-container">
                    <div class="p-4 bg-gray-700 rounded-lg text-white">Ch·ªù ph√¢n vai...</div>
                </div>
                <p class="mt-4 text-sm text-gray-400 italic">Ch√∫ √Ω: B·∫°n h√†nh ƒë·ªông ban ƒë√™m qua c√°c n√∫t d∆∞·ªõi t√™n ng∆∞·ªùi ch∆°i.</p>
            </div>
            
            <!-- B·∫£ng Theo D√µi Phi·∫øu B·∫ßu (M·ªõi) -->
            <div id="vote-tally-board" class="game-card-container p-6 hidden">
                <h2 class="text-xl font-bold text-amber-400 mb-4 flex items-center">
                    <i data-lucide="bar-chart-2" class="lucide mr-2 text-amber-400"></i>
                    B·∫£ng Theo D√µi Phi·∫øu B·∫ßu
                </h2>
                <div id="tally-results" class="space-y-3">
                    <!-- Tally results will be rendered here -->
                </div>
            </div>

             <!-- Danh s√°ch ng∆∞·ªùi ch∆°i -->
            <div class="game-card-container p-6">
                <h2 class="text-xl font-bold text-amber-400 mb-4 flex items-center">
                    <i data-lucide="list-checks" class="lucide mr-2 text-amber-400"></i>
                    Danh S√°ch Ng∆∞·ªùi Ch∆°i
                </h2>
                <div id="player-list" class="grid grid-cols-2 gap-4">
                    <!-- Danh s√°ch ng∆∞·ªùi ch∆°i ƒë∆∞·ª£c render t·∫°i ƒë√¢y -->
                </div>
            </div>

        </div>

        <!-- C·ªôt 2 & 3: Chat v√† Th·∫£o lu·∫≠n -->
        <div class="lg:col-span-2">
            <div class="game-card-container p-6">
                <h2 class="text-xl font-bold text-amber-400 mb-4 flex items-center">
                    <i data-lucide="skull" class="lucide mr-2 text-red-500"></i>
                    Ph√≤ng Th·∫£o Lu·∫≠n √Ånh TrƒÉng
                </h2>
                
                <!-- Chatbox -->
                <div id="chat-messages" class="mb-4 p-4 border border-gray-700 rounded-xl bg-gray-900 shadow-inner">
                    <!-- Tin nh·∫Øn ƒë∆∞·ª£c render t·∫°i ƒë√¢y -->
                </div>

                <!-- Input Chat -->
                <div class="flex space-x-2">
                    <input type="text" id="chat-input" placeholder="Vi·∫øt l·∫≠p lu·∫≠n c·ªßa b·∫°n..." 
                           class="flex-grow p-3 rounded-xl bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-500" disabled>
                    <button id="send-message-btn" onclick="handleSendMessage()" 
                            class="px-4 py-3 bg-cyan-600 text-white font-bold rounded-xl shadow-lg hover:bg-cyan-700 transition-colors flex items-center" disabled>
                        <i data-lucide="send" class="lucide"></i>
                    </button>
                    <!-- N√∫t B·ªè qua Giai ƒëo·∫°n -->
                    <button id="next-phase-btn" onclick="moveToNextPhase()" 
                            class="px-4 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-lg hover:bg-indigo-700 transition-colors flex items-center" disabled>
                        <i data-lucide="chevrons-right" class="lucide mr-1"></i> B·ªè Qua
                    </button>
                </div>
                <p class="mt-2 text-xs text-gray-500 italic">AI s·∫Ω tham gia th·∫£o lu·∫≠n t·ª± ƒë·ªông. B·∫°n c√≥ th·ªÉ nh·∫•n 'B·ªè Qua' ƒë·ªÉ chuy·ªÉn sang giai ƒëo·∫°n b·ªè phi·∫øu/ƒë√™m ngay.</p>
            </div>
        </div>

    </div>

    <script>
        // --- CONSTANTS AND STATE ---
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const API_KEY = ""; 
        const HUMAN_PLAYER_ID = 'human_player_123';

        const TOTAL_PLAYERS = 12; 
        const BOT_NAMES = ["An", "B√¨nh", "C√∫c", "D≈©ng", "Eun", "Ph√∫c", "Giang", "H√†", "Khoa", "Li√™n", "Minh"];
        const ROLES = ['Werewolf', 'Werewolf', 'Werewolf', 'Seer', 'Doctor', 'Witch', 'Bodyguard', 'Hunter', 'Villager', 'Villager', 'Villager', 'Villager']; 
        const ROLES_VN = {
            'Werewolf': 'Ma S√≥i üê∫',
            'Seer': 'Ti√™n Tri üîÆ',
            'Doctor': 'B√°c Sƒ© üíâ',
            'Witch': 'Ph√π Th·ªßy üß™',
            'Bodyguard': 'B·∫£o V·ªá üõ°Ô∏è',
            'Hunter': 'Th·ª£ SƒÉn üèπ',
            'Villager': 'D√¢n L√†ng üßë‚Äçüåæ'
        };
        const NIGHT_ACTORS = ['Werewolf', 'Seer', 'Doctor', 'Witch', 'Bodyguard']; 

        let gameState = {};
        let isProcessingAI = false;

        // --- UTILITIES ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = array[j];
            }
            return array;
        }

        function getChatHistory() {
            if (!gameState.messages) return "Ch∆∞a c√≥ tin nh·∫Øn n√†o.";
            return gameState.messages.slice(-25).map(msg => `${msg.senderName}: ${msg.text}`).join('\n');
        }

        function showLoading(show) {
            const overlay = document.getElementById('loading-overlay');
            if (show) {
                overlay.classList.remove('hidden');
                document.getElementById('start-btn').disabled = true;
                document.getElementById('next-phase-btn').disabled = true;
            } else {
                overlay.classList.add('hidden');
                document.getElementById('start-btn').disabled = false;
                document.getElementById('next-phase-btn').disabled = false;
            }
            isProcessingAI = show;
        }

        // --- GAME FLOW AND INITIALIZATION ---

        function startGameOffline() {
            const allPlayers = [{ id: HUMAN_PLAYER_ID, name: "B·∫°n (Human)", isBot: false }];
            for (let i = 0; i < TOTAL_PLAYERS - 1; i++) {
                allPlayers.push({ id: `bot_${i}`, name: BOT_NAMES[i], isBot: true });
            }

            const shuffledRoles = shuffleArray([...ROLES]);
            const playersWithRoles = allPlayers.map((player, index) => ({
                ...player,
                role: shuffledRoles[index],
                status: 'Alive',
                voteTargetId: null,
                actionTargetId: null,
                witchActionType: null 
            }));

            gameState = {
                phase: 'Discussion',
                dayCount: 1,
                players: playersWithRoles,
                messages: [],
                witchPotions: { heal: 1, kill: 1 },
                bodyguardLastProtected: null,
                winner: null
            };

            addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'Tr√≤ ch∆°i Ma S√≥i ƒê·∫°i Chi·∫øn AI ƒë√£ b·∫Øt ƒë·∫ßu v·ªõi 12 ng∆∞·ªùi ch∆°i! Ng√†y 1. H√£y b√†n lu·∫≠n.', 'GM');
            renderGameUI();
            processGameLogic();
        }

        // --- CORE GAME LOGIC ---

        function processGameLogic() {
            if (isProcessingAI || gameState.phase === 'GameOver') {
                return;
            }
            
            showLoading(false); // ƒê·∫£m b·∫£o overlay ·∫©n khi b·∫Øt ƒë·∫ßu logic m·ªõi

            switch (gameState.phase) {
                case 'Discussion':
                    handleDiscussionPhase();
                    break;
                case 'Voting':
                    handleVotingPhase();
                    break;
                case 'Night':
                    handleNightPhase();
                    break;
                case 'GameOver':
                    // Game Over
                    break;
            }
            renderGameUI();
        }

        async function handleDiscussionPhase() {
            // Logic cho BOT n√≥i
            showLoading(true);
            const aliveBots = gameState.players.filter(p => p.isBot && p.status === 'Alive');
            const discussionPromises = [];
            const speakingBots = shuffleArray(aliveBots).slice(0, Math.min(aliveBots.length, 6));

            for (const bot of speakingBots) {
                discussionPromises.push(generateAIResponse(bot, 'discussion'));
            }

            await Promise.all(discussionPromises);
            showLoading(false);
        }

        async function handleVotingPhase() {
            // Logic cho BOT b·ªè phi·∫øu
            showLoading(true);
            await addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'ƒê√É H·∫æT GI·ªú B√ÄN LU·∫¨N. M·ªùi m·ªçi ng∆∞·ªùi b·ªè phi·∫øu ƒë·ªÉ t√¨m ra Ma S√≥i!', 'GM');

            const aliveBots = gameState.players.filter(p => p.isBot && p.status === 'Alive');
            const votingPromises = [];

            for (const bot of aliveBots) {
                votingPromises.push(generateAIResponse(bot, 'vote'));
            }

            await Promise.all(votingPromises);
            
            // T·∫°m d·ª´ng ƒë·ªÉ ng∆∞·ªùi ch∆°i c√≥ th·ªùi gian b·ªè phi·∫øu, sau ƒë√≥ t·ª± ƒë·ªông b·ªè qua
            setTimeout(() => {
                if (gameState.phase === 'Voting') {
                    tallyVotes();
                }
            }, 5000); 

            showLoading(false);
        }

        async function handleNightPhase() {
             // Logic cho BOT h√†nh ƒë·ªông ban ƒë√™m
             showLoading(true);
             await addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'ƒê√É ƒê·∫æN ƒê√äM. Ma S√≥i, Ti√™n Tri, B√°c Sƒ©, Ph√π Th·ªßy v√† B·∫£o V·ªá h√£y h√†nh ƒë·ªông!', 'GM');

             const aliveBots = gameState.players.filter(p => p.isBot && p.status === 'Alive');
             const nightActionPromises = [];
             const actingBots = aliveBots.filter(p => NIGHT_ACTORS.includes(p.role));

             for (const bot of actingBots) {
                 nightActionPromises.push(generateAIResponse(bot, 'night_action'));
             }

             await Promise.all(nightActionPromises);
             
             // T·∫°m d·ª´ng ƒë·ªÉ ng∆∞·ªùi ch∆°i c√≥ th·ªùi gian h√†nh ƒë·ªông, sau ƒë√≥ t·ª± ƒë·ªông b·ªè qua
             setTimeout(() => {
                 if (gameState.phase === 'Night') {
                     executeNightActions();
                 }
             }, 5000);

             showLoading(false);
        }

        function tallyVotes() {
            if (gameState.phase !== 'Voting' || isProcessingAI) return;
            showLoading(true);

            const alivePlayers = gameState.players.filter(p => p.status === 'Alive');
            const voteCounts = {};
            let maxVotes = 0;
            let tiedPlayers = [];
            let executedPlayer = null;

            for (const player of alivePlayers) {
                if (player.voteTargetId) {
                    voteCounts[player.voteTargetId] = (voteCounts[player.voteTargetId] || 0) + 1;
                }
            }

            for (const targetId in voteCounts) {
                const votes = voteCounts[targetId];
                if (votes > maxVotes) {
                    maxVotes = votes;
                    tiedPlayers = [targetId];
                } else if (votes === maxVotes) {
                    tiedPlayers.push(targetId);
                }
            }
            
            let postExecutionMessage = '';
            let winCheckId = null; 

            if (tiedPlayers.length === 1 && maxVotes > 0) {
                const executedId = tiedPlayers[0];
                executedPlayer = gameState.players.find(p => p.id === executedId);
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                gameState.players = gameState.players.map(p => p.id === executedId ? { ...p, status: 'Dead' } : p);
                winCheckId = executedId;
                
                if (executedPlayer.role === 'Hunter') {
                    const newPlayers = gameState.players; 
                    const aliveTargets = newPlayers.filter(p => p.status === 'Alive' && p.id !== executedId);
                    if (aliveTargets.length > 0) {
                        const hunterShotId = shuffleArray(aliveTargets)[0].id;
                        const shotPlayer = gameState.players.find(p => p.id === hunterShotId);
                        postExecutionMessage = ` Th·ª£ SƒÉn ${executedPlayer.name} ƒë√£ k·ªãp b·∫Øn ${shotPlayer.name} (${ROLES_VN[shotPlayer.role]}) tr∆∞·ªõc khi ch·∫øt.`;
                        
                        gameState.players.forEach(p => {
                            if (p.id === hunterShotId) p.status = 'Dead';
                        });
                        winCheckId = hunterShotId; 
                    }
                }

                addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', `${executedPlayer.name} (${ROLES_VN[executedPlayer.role]}) ƒë√£ b·ªã treo c·ªï! ${postExecutionMessage}`, 'GM');

            } else {
                 addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'Ng√†y h√¥m nay h√≤a phi·∫øu ho·∫∑c kh√¥ng ai b·ªã treo c·ªï.', 'GM');
            }
            
            checkWinCondition(winCheckId);
            
            if (gameState.phase !== 'GameOver') {
                moveToNextPhase('Night');
            }
            showLoading(false);
        }

        function executeNightActions() {
            if (gameState.phase !== 'Night' || isProcessingAI) return;
            showLoading(true);

            const actions = gameState.players.filter(p => p.actionTargetId);

            // 1. Werewolf Kill Determination
            let killTargetId = null;
            const werewolves = actions.filter(p => p.role === 'Werewolf');
            if (werewolves.length > 0) {
                const killVotes = {};
                werewolves.forEach(w => killVotes[w.actionTargetId] = (killVotes[w.actionTargetId] || 0) + 1);
                const killTargets = Object.entries(killVotes).sort(([, a], [, b]) => b - a);
                if (killTargets.length > 0) {
                    killTargetId = killTargets[0][0]; 
                }
            }

            // 2. Protection (Doctor & Bodyguard)
            const doctor = actions.find(p => p.role === 'Doctor');
            const bodyguard = actions.find(p => p.role === 'Bodyguard');
            
            let savedTargetId = doctor ? doctor.actionTargetId : null;
            let protectedTargetId = bodyguard ? bodyguard.actionTargetId : null;
            let finalKilledByWolfId = killTargetId;
            
            let wolfKillMessage = '';
            
            if (killTargetId) {
                if (killTargetId === savedTargetId) {
                    finalKilledByWolfId = null; wolfKillMessage = `${gameState.players.find(p => p.id === killTargetId).name} ƒë√£ ƒë∆∞·ª£c B√°c Sƒ© c·ª©u! `;
                } else if (killTargetId === protectedTargetId) {
                    finalKilledByWolfId = null; wolfKillMessage = `${gameState.players.find(p => p.id === killTargetId).name} ƒë√£ ƒë∆∞·ª£c B·∫£o V·ªá! `;
                }
            }
            
            // 3. Witch Actions
            const witch = actions.find(p => p.role === 'Witch');
            let killedByWitchId = null;
            let newWitchPotions = { ...gameState.witchPotions };

            if (witch) {
                const witchAction = actions.find(p => p.id === witch.id);
                const actionType = witchAction ? witchAction.witchActionType : null;

                if (actionType === 'Heal' && newWitchPotions.heal > 0) {
                    if (finalKilledByWolfId === witchAction.actionTargetId) {
                         finalKilledByWolfId = null;
                         wolfKillMessage += `${gameState.players.find(p => p.id === witchAction.actionTargetId).name} ƒë∆∞·ª£c Ph√π Th·ªßy c·ª©u! `;
                         newWitchPotions.heal -= 1;
                    }
                } else if (actionType === 'Kill' && newWitchPotions.kill > 0) {
                    killedByWitchId = witchAction.actionTargetId;
                    newWitchPotions.kill -= 1;
                }
            }

            // 4. Seer Reveal (private system message)
            const seerActor = actions.find(p => p.role === 'Seer');
            if (seerActor) {
                const target = gameState.players.find(p => p.id === seerActor.actionTargetId);
                const revealMessage = `[GM -> ${seerActor.name}]: ${target.name} l√† ${ROLES_VN[target.role]}.`;
                addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', revealMessage, 'System_Private');
            }


            // 5. Determine Final Death and Hunter Effect
            let finalKilledId = finalKilledByWolfId || killedByWitchId;
            let nightMessage = wolfKillMessage;
            let winCheckId = finalKilledId;

            if (finalKilledId) {
                const killedPlayer = gameState.players.find(p => p.id === finalKilledId);
                
                // Update player status
                gameState.players = gameState.players.map(p => p.id === finalKilledId ? { ...p, status: 'Dead' } : p);
                
                const killSource = finalKilledByWolfId ? 'Ma S√≥i' : 'Ph√π Th·ªßy';
                nightMessage += `${killedPlayer.name} (${ROLES_VN[killedPlayer.role]}) ƒë√£ ch·∫øt v√¨ b·ªã ${killSource} t·∫•n c√¥ng.`;
                
                // Hunter Death Effect
                if (killedPlayer.role === 'Hunter') {
                    const hunter = killedPlayer;
                    const aliveTargets = gameState.players.filter(p => p.status === 'Alive' && p.id !== hunter.id);
                    if (aliveTargets.length > 0) {
                        const hunterShotId = shuffleArray(aliveTargets)[0].id;
                        const shotPlayer = gameState.players.find(p => p.id === hunterShotId);
                        nightMessage += ` Th·ª£ SƒÉn ${hunter.name} ƒë√£ k·ªãp b·∫Øn ${shotPlayer.name} (${ROLES_VN[shotPlayer.role]}) tr∆∞·ªõc khi ch·∫øt.`;
                        gameState.players.forEach(p => {
                            if (p.id === hunterShotId) p.status = 'Dead';
                        });
                        winCheckId = hunterShotId; 
                    }
                }
            } else {
                if (!nightMessage.includes('c·ª©u') && !nightMessage.includes('B·∫£o V·ªá')) {
                    nightMessage += 'Kh√¥ng ai b·ªã gi·∫øt ƒë√™m nay.';
                }
            }

            // 6. Update Game State for next day
            gameState.dayCount += 1;
            gameState.phase = 'Discussion';
            gameState.witchPotions = newWitchPotions;
            gameState.bodyguardLastProtected = protectedTargetId;

            // Reset player actions
             gameState.players = gameState.players.map(p => ({ 
                ...p, 
                voteTargetId: null, 
                actionTargetId: null,
                witchActionType: null 
            }));


            addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', nightMessage, 'GM');
            checkWinCondition(winCheckId);
            
            if (gameState.phase !== 'GameOver') {
                processGameLogic(); // B·∫Øt ƒë·∫ßu Giai ƒëo·∫°n Th·∫£o lu·∫≠n m·ªõi
            }
            showLoading(false);
        }
        
        function checkWinCondition(lastKilledId) {
            const aliveWerewolves = gameState.players.filter(p => p.status === 'Alive' && p.role === 'Werewolf').length;
            const aliveVillagers = gameState.players.filter(p => p.status === 'Alive' && ['Villager', 'Seer', 'Doctor', 'Witch', 'Bodyguard', 'Hunter'].includes(p.role)).length;

            let winner = null;
            if (aliveWerewolves >= aliveVillagers) {
                winner = 'Werewolves';
            } else if (aliveWerewolves === 0) {
                winner = 'Villagers';
            }

            if (winner) {
                gameState.phase = 'GameOver';
                gameState.winner = winner;
                addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', `TR√í CH∆†I K·∫æT TH√öC! Phe ${winner} chi·∫øn th·∫Øng!`, 'GM');
            }
        }

        function moveToNextPhase(nextPhase = null) {
            if (isProcessingAI || gameState.phase === 'GameOver') return;
            
            if (!nextPhase) {
                if (gameState.phase === 'Discussion') {
                    nextPhase = 'Voting';
                } else if (gameState.phase === 'Voting') {
                    tallyVotes(); // T·ª± ƒë·ªông ch·∫•m phi·∫øu v√† chuy·ªÉn sang ƒë√™m
                    return; 
                } else if (gameState.phase === 'Night') {
                    executeNightActions(); // T·ª± ƒë·ªông th·ª±c hi·ªán h√†nh ƒë·ªông ƒë√™m v√† chuy·ªÉn sang ng√†y
                    return;
                }
            }
            
            if (nextPhase) {
                 // Reset player actions only if moving to a new day/night cycle
                 if (nextPhase === 'Night' || nextPhase === 'Discussion') {
                     gameState.players = gameState.players.map(p => ({ 
                        ...p, 
                        voteTargetId: null, 
                        actionTargetId: null,
                        witchActionType: null 
                    }));
                }
                if (nextPhase === 'Discussion') {
                    gameState.dayCount += 1;
                }

                gameState.phase = nextPhase;
                processGameLogic();
            }
        }
        
        // --- AI INTEGRATION (GEMINI) ---

        async function generateAIResponse(bot, actionType) {
            const alivePlayers = gameState.players.filter(p => p.status === 'Alive');
            const otherAlivePlayers = alivePlayers.filter(p => p.id !== bot.id);
            const alivePlayerNames = otherAlivePlayers.map(p => p.name).join(', ');
            
            let systemInstruction = "";
            let userQuery = "";
            let expectedJsonSchema = null;

            const chatHistory = getChatHistory();
            
            const werewolfCount = gameState.players.filter(p => p.role === 'Werewolf' && p.status === 'Alive').length;
            const villagerCount = gameState.players.filter(p => p.status === 'Alive' && ['Villager', 'Seer', 'Doctor', 'Witch', 'Bodyguard', 'Hunter'].includes(p.role)).length;

            const commonContext = `
                B·∫°n l√† m·ªôt ng∆∞·ªùi ch∆°i Ma S√≥i th√¥ng minh, t√™n l√† ${bot.name} (${ROLES_VN[bot.role]}).
                B·∫°n ƒëang trong Ng√†y ${gameState.dayCount}. S·ªë l∆∞·ª£ng phe D√¢n L√†ng (bao g·ªìm vai tr√≤) c√≤n s·ªëng: ${villagerCount}. S·ªë l∆∞·ª£ng Ma S√≥i c√≤n s·ªëng: ${werewolfCount}.
                B·∫°n ph·∫£i c·ªë g·∫Øng h·∫øt s·ª©c ƒë·ªÉ b·∫£o v·ªá phe c·ªßa m√¨nh v√† chi·∫øn th·∫Øng.
                C√°c ng∆∞·ªùi ch∆°i c√≤n s·ªëng l√†: ${alivePlayerNames}.
                L·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán g·∫ßn nh·∫•t:
                ---
                ${chatHistory}
                ---
                Vai tr√≤ v√† H√†nh ƒë·ªông Ban ƒê√™m:
                - Werewolf (Ma S√≥i): Gi·∫øt ng∆∞·ªùi (tr·ª´ b·∫£n th√¢n).
                - Seer (Ti√™n Tri): Soi vai ng∆∞·ªùi kh√°c.
                - Doctor (B√°c Sƒ©): C·ª©u ng∆∞·ªùi b·ªã Ma S√≥i gi·∫øt (kh√¥ng th·ªÉ t·ª± c·ª©u).
                - Witch (Ph√π Th·ªßy): C√≥ 1 b√¨nh C·ª©u v√† 1 b√¨nh Gi·∫øt. (ƒê√£ d√πng C·ª©u: ${1 - gameState.witchPotions.heal}, ƒê√£ d√πng Gi·∫øt: ${1 - gameState.witchPotions.kill}).
                - Bodyguard (B·∫£o V·ªá): B·∫£o v·ªá 1 ng∆∞·ªùi (kh√¥ng ƒë∆∞·ª£c b·∫£o v·ªá ng∆∞·ªùi ƒë√£ b·∫£o v·ªá ƒë√™m tr∆∞·ªõc, ƒë√™m tr∆∞·ªõc l√†: ${gameState.players.find(p => p.id === gameState.bodyguardLastProtected)?.name || 'Kh√¥ng ai'}).
            `;
            
            if (actionType === 'discussion') {
                systemInstruction = commonContext + `
                    Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë∆∞a ra m·ªôt l·∫≠p lu·∫≠n s·∫Øc b√©n, thuy·∫øt ph·ª•c ƒë·ªÉ:
                    - N·∫øu l√† Ma S√≥i: G√¢y nghi ng·ªù v·ªÅ m·ªôt ng∆∞·ªùi v√¥ t·ªôi ho·∫∑c b√†o ch·ªØa cho b·∫£n th√¢n/ƒë·ªìng ƒë·ªôi. ƒê·ª´ng bao gi·ªù ti·∫øt l·ªô b·∫°n l√† Ma S√≥i.
                    - N·∫øu l√† D√¢n L√†ng: ƒê∆∞a ra nh·∫≠n ƒë·ªãnh d·ª±a tr√™n logic v√† quan s√°t h√†nh vi. Ti√™n Tri n√™n c·∫©n th·∫≠n khi c√¥ng khai th√¥ng tin.
                    Lu·∫≠n ƒëi·ªÉm c·ªßa b·∫°n ph·∫£i ng·∫Øn g·ªçn (T·ªêI ƒêA 2 C√ÇU), m·∫°nh m·∫Ω v√† b·∫±ng ti·∫øng Vi·ªát.
                `;
                userQuery = `Ng√†y ${gameState.dayCount}. T√¥i (${bot.name}, ${ROLES_VN[bot.role]}) n√™n n√≥i g√¨ ƒë·ªÉ ƒë√≥ng g√≥p v√†o cu·ªôc tranh lu·∫≠n?`;

            } else if (actionType === 'vote') {
                systemInstruction = commonContext + `
                    Nhi·ªám v·ª• c·ªßa b·∫°n l√† b·ªè phi·∫øu cho ng∆∞·ªùi ch∆°i m√† b·∫°n tin r·∫±ng l√† Ma S√≥i.
                    - N·∫øu l√† Ma S√≥i: H√£y b·ªè phi·∫øu cho m·ªôt ng∆∞·ªùi v√¥ t·ªôi b·ªã nhi·ªÅu ng∆∞·ªùi nghi ng·ªù nh·∫•t. KH√îNG b·ªè phi·∫øu cho ƒë·ªìng ƒë·ªôi Ma S√≥i c·ªßa b·∫°n.
                    - N·∫øu l√† D√¢n L√†ng: B·ªè phi·∫øu cho ng∆∞·ªùi m√† b·∫°n nghi ng·ªù nh·∫•t d·ª±a tr√™n l·∫≠p lu·∫≠n.
                    B·∫°n PH·∫¢I tr·∫£ l·ªùi b·∫±ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON.
                `;
                userQuery = `Ng√†y ${gameState.dayCount}. T√¥i (${bot.name}, ${ROLES_VN[bot.role]}) n√™n b·ªè phi·∫øu cho ai? Ch·ªâ ch·ªçn m·ªôt ng∆∞·ªùi t·ª´ danh s√°ch c√≤n s·ªëng.`;
                expectedJsonSchema = {
                    type: "OBJECT",
                    properties: {
                        voteTargetName: { type: "STRING", description: "T√™n ng∆∞·ªùi ch∆°i b·∫°n mu·ªën b·ªè phi·∫øu cho." },
                        voteReason: { type: "STRING", description: "L√Ω do ng·∫Øn g·ªçn (1 c√¢u) cho s·ª± l·ª±a ch·ªçn b·ªè phi·∫øu." }
                    }
                };

            } else if (actionType === 'night_action') {
                 systemInstruction = commonContext + `
                    Nhi·ªám v·ª• c·ªßa b·∫°n l√† th·ª±c hi·ªán h√†nh ƒë·ªông ban ƒë√™m.
                    - Werewolf: Ch·ªçn m·ªôt ng∆∞·ªùi ch∆°i (tr·ª´ m√¨nh) ƒë·ªÉ gi·∫øt.
                    - Bodyguard: Kh√¥ng b·∫£o v·ªá ng∆∞·ªùi ƒë√™m tr∆∞·ªõc (${gameState.players.find(p => p.id === gameState.bodyguardLastProtected)?.name || 'Kh√¥ng ai'}).
                    - Witch: C·ªë g·∫Øng d√πng b√¨nh C·ª©u (n·∫øu c√≤n) ƒë·ªÉ c·ª©u n·∫°n nh√¢n ƒë√™m nay. N·∫øu kh√¥ng c·∫ßn c·ª©u, h√£y d√πng b√¨nh Gi·∫øt (n·∫øu c√≤n) l√™n m·ªôt ng∆∞·ªùi b·∫°n nghi ng·ªù l√† Ma S√≥i.
                    B·∫°n PH·∫¢I tr·∫£ l·ªùi b·∫±ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON.
                `;
                userQuery = `ƒê√™m ${gameState.dayCount}. T√¥i (${bot.name}, ${ROLES_VN[bot.role]}) n√™n th·ª±c hi·ªán h√†nh ƒë·ªông ban ƒë√™m l√™n ai?
                N·∫øu l√† Ph√π Th·ªßy, h√£y th√™m tr∆∞·ªùng 'potionType' v√†o JSON ('Heal' ho·∫∑c 'Kill').
                `;
                expectedJsonSchema = {
                    type: "OBJECT",
                    properties: {
                        actionTargetName: { type: "STRING", description: "T√™n ng∆∞·ªùi ch∆°i l√† m·ª•c ti√™u h√†nh ƒë·ªông ban ƒë√™m c·ªßa b·∫°n." },
                        actionReason: { type: "STRING", description: "L√Ω do ng·∫Øn g·ªçn (1 c√¢u) cho h√†nh ƒë·ªông n√†y." },
                        potionType: { type: "STRING", description: "Ch·ªâ cho Ph√π Th·ªßy: 'Heal' ho·∫∑c 'Kill'." }
                    }
                };
            }

            try {
                const fetchOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemInstruction }] },
                        ...(expectedJsonSchema && { 
                            generationConfig: {
                                responseMimeType: "application/json",
                                responseSchema: expectedJsonSchema
                            }
                        })
                    })
                };

                const response = await fetch(API_URL + API_KEY, fetchOptions);
                const result = await response.json();
                const textResult = result.candidates?.[0]?.content?.parts?.[0]?.text || "L·ªói AI: Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi.";

                if (actionType === 'discussion') {
                    let shortText = textResult.split('. ').slice(0, 2).join('. ');
                    if (textResult.split('. ').length > 2) shortText += '...';
                    addMessage(bot.name, shortText, bot.role);
                } else {
                    try {
                        const jsonResponse = JSON.parse(textResult);
                        const targetName = jsonResponse.voteTargetName || jsonResponse.actionTargetName;
                        const reason = jsonResponse.voteReason || jsonResponse.actionReason;
                        const potionType = jsonResponse.potionType || null;
                        const targetPlayer = gameState.players.find(p => p.name === targetName && p.status === 'Alive');
                        
                        if (targetPlayer) {
                            if (actionType === 'vote') {
                                updatePlayerAction(bot.id, targetPlayer.id, 'vote', null);
                                addMessage(bot.name, `*ƒê√£ b·ªè phi·∫øu cho ${targetPlayer.name} (${reason})*`, 'System_Bot');
                            } else if (actionType === 'night_action') {
                                updatePlayerAction(bot.id, targetPlayer.id, 'night_action', potionType);
                                let msg = `*ƒê√£ th·ª±c hi·ªán h√†nh ƒë·ªông (${ROLES_VN[bot.role]}) l√™n ${targetPlayer.name}.`;
                                if (potionType) msg += ` Potion: ${potionType}.`;
                                msg += ` (${reason})*`;
                                addMessage(bot.name, msg, 'System_Bot');
                            }
                        } else {
                             addMessage(bot.name, `L·ªói AI: ƒê√£ ch·ªçn m·ª•c ti√™u kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ch·∫øt (${targetName}). B·ªè qua h√†nh ƒë·ªông.`, 'System_Bot_Error');
                        }
                    } catch (e) {
                         addMessage(bot.name, `L·ªói Ph√¢n T√≠ch JSON AI. Ph·∫£n h·ªìi: ${textResult}. L·ªói: ${e.message}`, 'System_Bot_Error');
                    }
                }

            } catch (error) {
                console.error(`L·ªói g·ªçi Gemini cho ${bot.name} (${actionType}):`, error);
                addMessage(bot.name, `L·ªói k·∫øt n·ªëi AI. B·ªè qua l∆∞·ª£t.`, 'System_Bot_Error');
            }
        }
        
        // --- DATA MUTATION (NO FIRESTORE) ---
        
        function addMessage(senderName, text, role) {
            gameState.messages.push({
                senderName,
                text,
                role,
                timestamp: Date.now()
            });
            renderChat();
        }

        function updatePlayerAction(playerId, targetId, actionType, witchActionType = null) {
            const playerIndex = gameState.players.findIndex(p => p.id === playerId);
            if (playerIndex !== -1) {
                if (actionType === 'vote') {
                    gameState.players[playerIndex].voteTargetId = targetId;
                } else if (actionType === 'night_action') {
                    gameState.players[playerIndex].actionTargetId = targetId;
                    if (gameState.players[playerIndex].role === 'Witch') {
                         gameState.players[playerIndex].witchActionType = witchActionType;
                    }
                }
            }
            renderGameUI(); // Re-render after state change
        }

        // --- UI RENDERING ---
        
        function renderRoleCard(player) {
            const roleVN = ROLES_VN[player.role] || '·∫®n Danh';
            
            const roleColor = player.role === 'Werewolf' ? 'bg-red-900 border-red-600' : 
                              player.role === 'Seer' ? 'bg-indigo-900 border-indigo-600' :
                              player.role === 'Doctor' ? 'bg-cyan-900 border-cyan-600' :
                              player.role === 'Witch' ? 'bg-purple-900 border-purple-600' :
                              player.role === 'Bodyguard' ? 'bg-amber-900 border-amber-600' :
                              player.role === 'Hunter' ? 'bg-orange-900 border-orange-600' :
                              'bg-green-900 border-green-600'; 
            
            let extraInfo = '';
            if (player.role === 'Witch' && gameState.witchPotions) {
                 extraInfo = `<p class="text-sm opacity-90 mt-1">B√¨nh C·ª©u: ${gameState.witchPotions.heal} | B√¨nh Gi·∫øt: ${gameState.witchPotions.kill}</p>`;
            } else if (player.role === 'Bodyguard') {
                 const lastProtectedName = gameState.players.find(p => p.id === gameState.bodyguardLastProtected)?.name || 'Kh√¥ng ai';
                 extraInfo = `<p class="text-sm opacity-90 mt-1">ƒê√™m tr∆∞·ªõc b·∫£o v·ªá: ${lastProtectedName}</p>`;
            }

            return `
                <div class="p-4 rounded-xl shadow-2xl ${roleColor} text-white font-bold transform transition-transform border-b-4 border-r-4">
                    <p class="text-xl">${player.name}</p>
                    <p class="text-sm opacity-90">${roleVN}</p>
                    ${extraInfo}
                </div>
            `;
        }

        function renderPlayerList() {
            const container = document.getElementById('player-list');
            container.innerHTML = '';
            
            if (!gameState.players) return;

            const humanPlayer = gameState.players.find(p => p.id === HUMAN_PLAYER_ID);
            
            gameState.players.forEach(player => {
                const isAlive = player.status === 'Alive';
                const isTargetable = isAlive && player.id !== HUMAN_PLAYER_ID;
                
                let targetButtons = '';
                const baseClass = "mt-1 w-full text-white py-2 rounded-lg transition-colors font-semibold shadow-md";

                if (gameState.phase === 'Voting' && isTargetable && humanPlayer.status === 'Alive') {
                    targetButtons = `<button onclick="handleActionClick('${player.id}', 'vote')" class="bg-amber-600 hover:bg-amber-700 ${baseClass}">B·ªè Phi·∫øu</button>`;
                } else if (gameState.phase === 'Night' && isTargetable && humanPlayer.status === 'Alive') {
                    
                    if (NIGHT_ACTORS.includes(humanPlayer.role)) {
                         if (humanPlayer.role === 'Witch') {
                            if (gameState.witchPotions.heal > 0) {
                                targetButtons += `<button onclick="handleActionClick('${player.id}', 'night_action_heal')" class="bg-cyan-600 hover:bg-cyan-700 ${baseClass}">C·ª©u (üß™)</button>`;
                            }
                            if (gameState.witchPotions.kill > 0) {
                                targetButtons += `<button onclick="handleActionClick('${player.id}', 'night_action_kill')" class="bg-red-700 hover:bg-red-800 ${baseClass}">Gi·∫øt (üî™)</button>`;
                            }
                         } else if (humanPlayer.role === 'Werewolf') {
                            if (player.id !== HUMAN_PLAYER_ID) {
                                targetButtons = `<button onclick="handleActionClick('${player.id}', 'night_action_wolf')" class="bg-red-700 hover:bg-red-800 ${baseClass}">Gi·∫øt (üê∫)</button>`;
                            }
                         } else if (humanPlayer.role === 'Bodyguard') {
                            if (player.id !== gameState.bodyguardLastProtected) { 
                                targetButtons = `<button onclick="handleActionClick('${player.id}', 'night_action_guard')" class="bg-indigo-600 hover:bg-indigo-700 ${baseClass}">B·∫£o V·ªá (üõ°Ô∏è)</button>`;
                            } else {
                                targetButtons = `<button disabled class="bg-gray-600 opacity-60 ${baseClass}">V·ª´a B·∫£o V·ªá</button>`;
                            }
                         } else { // Seer, Doctor
                             targetButtons = `<button onclick="handleActionClick('${player.id}', 'night_action_generic')" class="bg-blue-600 hover:bg-blue-700 ${baseClass}">H√†nh ƒê·ªông</button>`;
                         }
                    }
                }
                
                const currentVotes = gameState.players.filter(p => p.voteTargetId === player.id).length;
                const card = `
                    <div class="p-3 bg-gray-800 rounded-xl shadow-lg transition-all hover:shadow-xl ${isAlive ? 'border border-green-500/50' : 'border border-red-500/50 opacity-60'}">
                        <p class="text-white font-bold text-lg">${player.name} ${player.id === HUMAN_PLAYER_ID ? '(B·∫°n)' : ''}</p>
                        <p class="text-sm ${isAlive ? 'text-green-400' : 'text-red-400'}">${isAlive ? 'C√≤n S·ªëng' : 'ƒê√£ Ch·∫øt'}</p>
                        ${isAlive ? `<p class="text-xs text-blue-300 mt-1">Phi·∫øu ƒë√£ b·∫ßu: ${currentVotes}</p>` : ''}
                        <div class="mt-2 space-y-1">${targetButtons}</div>
                    </div>
                `;
                container.innerHTML += card;
            });
        }
        
        function renderChat() {
            const chatBox = document.getElementById('chat-messages');
            chatBox.innerHTML = '';
            
            if (!gameState.messages) return;

            gameState.messages.forEach(msg => {
                const isBot = msg.senderName !== 'B·∫°n (Human)' && msg.senderName !== 'Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)';
                const isGM = msg.role === 'GM';
                const isSystem = msg.role && msg.role.startsWith('System');

                let senderClass = 'font-bold text-amber-400';
                let messageClass = 'bg-gray-700 text-gray-100';

                if (isGM) {
                    senderClass = 'font-black text-red-500';
                    messageClass = 'bg-gray-800 text-red-300 italic border border-red-900';
                } else if (isBot) {
                    senderClass = 'font-bold text-blue-400';
                    messageClass = 'bg-gray-700 text-gray-100';
                } else if (isSystem) {
                    senderClass = 'font-bold text-purple-400';
                    messageClass = 'bg-gray-900 text-purple-300 text-xs border border-purple-900';
                }
                
                const html = `
                    <div class="mb-2">
                        <span class="${senderClass}">${msg.senderName}</span>: 
                        <span class="${messageClass} px-2 py-1 rounded-lg inline-block break-words shadow-inner">${msg.text}</span>
                    </div>
                `;
                chatBox.innerHTML += html;
            });
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function renderVoteTally() {
            const tallyBoard = document.getElementById('tally-results');
            const tallyBoardContainer = document.getElementById('vote-tally-board');
            tallyBoard.innerHTML = '';
            
            if (gameState.phase !== 'Voting') {
                tallyBoardContainer.classList.add('hidden');
                return;
            }
            
            tallyBoardContainer.classList.remove('hidden');

            const alivePlayers = gameState.players.filter(p => p.status === 'Alive');
            const totalVoters = alivePlayers.length;
            const voteCounts = {};
            
            for (const player of alivePlayers) {
                if (player.voteTargetId) {
                    voteCounts[player.voteTargetId] = (voteCounts[player.voteTargetId] || 0) + 1;
                }
            }

            const tallyList = [];
            for (const targetId in voteCounts) {
                const targetPlayer = gameState.players.find(p => p.id === targetId);
                if (targetPlayer) {
                    tallyList.push({ name: targetPlayer.name, votes: voteCounts[targetId] });
                }
            }
            
            tallyList.sort((a, b) => b.votes - a.votes);
            
            if (tallyList.length === 0) {
                tallyBoard.innerHTML = '<p class="text-gray-400 italic">Ch∆∞a c√≥ phi·∫øu b·∫ßu n√†o.</p>';
                return;
            }
            
            const maxVotes = tallyList[0].votes;

            tallyList.forEach(item => {
                const percentage = (item.votes / totalVoters) * 100;
                const barColor = item.votes === maxVotes ? 'bg-red-600' : 'bg-amber-500';

                const tallyItem = `
                    <div class="text-white">
                        <div class="flex justify-between text-sm mb-1">
                            <span class="font-semibold">${item.name}</span>
                            <span class="font-bold">${item.votes} phi·∫øu</span>
                        </div>
                        <div class="w-full bg-gray-600 rounded-full h-2.5">
                            <div class="${barColor} h-2.5 rounded-full transition-all duration-500" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
                tallyBoard.innerHTML += tallyItem;
            });
        }


        function renderGameUI() {
            if (!gameState.players) return;
            
            const humanPlayer = gameState.players.find(p => p.id === HUMAN_PLAYER_ID);
            const aliveWerewolves = gameState.players.filter(p => p.status === 'Alive' && p.role === 'Werewolf').length;
            const aliveVillagers = gameState.players.filter(p => p.status === 'Alive' && ['Villager', 'Seer', 'Doctor', 'Witch', 'Bodyguard', 'Hunter'].includes(p.role)).length;

            if (humanPlayer) {
                document.getElementById('role-card-container').innerHTML = renderRoleCard(humanPlayer);
            }
            
            const phaseText = gameState.phase === 'Night' ? 'ƒê√äM THAO T√öNG üåë' : 
                              gameState.phase === 'Discussion' ? 'NG√ÄY TRANH LU·∫¨N ‚òÄÔ∏è' : 
                              gameState.phase === 'Voting' ? 'B·ªé PHI·∫æU TREO C·ªî üî™' : 
                              `K·∫æT TH√öC üèÅ (Phe ${gameState.winner === 'Werewolves' ? 'MA S√ìI' : 'D√ÇN L√ÄNG'} th·∫Øng)`;
            
            document.getElementById('game-status').innerHTML = `
                <p class="text-3xl font-extrabold text-white mb-2">
                    ${phaseText}
                </p>
                <p class="text-xl font-bold text-amber-300">Ng√†y ${gameState.dayCount}</p>
                <p class="text-sm text-gray-400">D√¢n L√†ng: ${aliveVillagers} | Ma S√≥i: ${aliveWerewolves}</p>
            `;

            renderPlayerList();
            renderVoteTally(); 
            lucide.createIcons(); // Re-render icons after DOM update

            const chatInput = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-message-btn');
            const nextPhaseBtn = document.getElementById('next-phase-btn');
            
            const canSpeak = gameState.phase === 'Discussion' && humanPlayer && humanPlayer.status === 'Alive';
            const canNextPhase = gameState.phase !== 'GameOver' && !isProcessingAI;

            chatInput.disabled = !canSpeak;
            sendBtn.disabled = !canSpeak;
            nextPhaseBtn.disabled = !canNextPhase;
            
            if (gameState.phase === 'GameOver') {
                nextPhaseBtn.disabled = true;
                nextPhaseBtn.textContent = 'Game Over';
            } else {
                 nextPhaseBtn.textContent = 'B·ªè Qua';
            }
            
            if (!canSpeak) {
                 chatInput.placeholder = (gameState.phase === 'Night') ? "Ban ƒë√™m, kh√¥ng ƒë∆∞·ª£c n√≥i." : "ƒê√£ ch·∫øt ho·∫∑c kh√¥ng trong giai ƒëo·∫°n n√≥i chuy·ªán.";
            } else {
                 chatInput.placeholder = "Vi·∫øt l·∫≠p lu·∫≠n c·ªßa b·∫°n...";
            }
        }
        
        // --- HANDLERS T∆Ø∆†NG T√ÅC NG∆Ø·ªúI CH∆†I ---

        function handleSendMessage() {
            const chatInput = document.getElementById('chat-input');
            const message = chatInput.value.trim();
            if (message && gameState.phase === 'Discussion' && gameState.players.find(p => p.id === HUMAN_PLAYER_ID).status === 'Alive') {
                addMessage("B·∫°n (Human)", message, gameState.players.find(p => p.id === HUMAN_PLAYER_ID).role);
                chatInput.value = '';
            }
        }

        function handleActionClick(targetId, actionType) {
            const humanPlayer = gameState.players.find(p => p.id === HUMAN_PLAYER_ID);
            if (!humanPlayer || humanPlayer.status === 'Dead' || isProcessingAI) return;
            
            const targetPlayer = gameState.players.find(p => p.id === targetId);
            if (!targetPlayer || targetPlayer.status === 'Dead') return;

            if (actionType === 'vote' && gameState.phase === 'Voting') {
                 updatePlayerAction(HUMAN_PLAYER_ID, targetId, 'vote', null);
                 addMessage("B·∫°n (Human)", `*ƒê√£ b·ªè phi·∫øu cho ${targetPlayer.name}*`, 'System_Human');

            } else if (actionType.startsWith('night_action') && gameState.phase === 'Night') {
                let witchActionType = null;
                
                if (humanPlayer.role === 'Werewolf' && targetId === HUMAN_PLAYER_ID) {
                    addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'Ma S√≥i kh√¥ng th·ªÉ gi·∫øt ch√≠nh m√¨nh!', 'System_Error');
                    return;
                }

                if (humanPlayer.role === 'Bodyguard' && targetId === gameState.bodyguardLastProtected) {
                    addMessage('Ng∆∞·ªùi Qu·∫£n Tr√≤ (GM)', 'B·∫£o v·ªá kh√¥ng ƒë∆∞·ª£c b·∫£o v·ªá ng∆∞·ªùi ƒë√™m tr∆∞·ªõc!', 'System_Error');
                    return;
                }
                
                if (humanPlayer.role === 'Witch') {
                    if (actionType.includes('heal')) {
                        if (gameState.witchPotions.heal <= 0) return;
                        witchActionType = 'Heal';
                    } else if (actionType.includes('kill')) {
                        if (gameState.witchPotions.kill <= 0) return;
                        witchActionType = 'Kill';
                    } else return;
                }

                updatePlayerAction(HUMAN_PLAYER_ID, targetId, 'night_action', witchActionType);
                let msg = `*ƒê√£ th·ª±c hi·ªán h√†nh ƒë·ªông ƒë√™m (${ROLES_VN[humanPlayer.role]}).`;
                if (witchActionType) msg += ` Potion: ${witchActionType}.`;
                msg += ` M·ª•c ti√™u: ${targetPlayer.name}*`;
                addMessage("B·∫°n (Human)", msg, 'System_Human');
            }
        }

        window.onload = () => {
             // Kh·ªüi t·∫°o tr·∫°ng th√°i ban ƒë·∫ßu ƒë·ªÉ giao di·ªán kh√¥ng b·ªã l·ªói
             gameState = { phase: 'Starting', dayCount: 0, players: null, messages: [], witchPotions: { heal: 1, kill: 1 }, bodyguardLastProtected: null, winner: null };
             renderGameUI();
        };
        window.startGameOffline = startGameOffline;
        window.handleSendMessage = handleSendMessage;
        window.handleActionClick = handleActionClick;
        window.moveToNextPhase = moveToNextPhase;
    </script>
</body>
</html> 